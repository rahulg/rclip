#!/usr/bin/env python3

import binascii
import hmac
import logging
import os
import socket
import struct
import subprocess
import sys
import time

from enum import Enum
from pathlib import Path

DEFAULT_PORT = 9110
TIME_DRIFT_ALLOWANCE = 2

MAX_MSG_LEN = 2**16 - 1
try:
    XDG_CONFIG_HOME = Path(os.environ['XDG_CONFIG_HOME'])
except KeyError:
    XDG_CONFIG_HOME = Path.home() / '.config'
CONFIG_DIR = XDG_CONFIG_HOME / 'rclip'
SECRET_FILE = CONFIG_DIR / 'secret'
SECRET_SIZE = 32

logging.basicConfig(
    level=os.environ.get('LOGLEVEL', 'WARNING'),
    style='{',
    format='[{asctime}] {levelname}: {message}',
)


def opoo(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


class MessageTooLargeError(Exception):
    pass


class AuthenticationError(Exception):
    pass


class ServerExistsError(Exception):
    pass


class CopyFailedError(Exception):
    pass


class RClipProtocolError(Exception):
    pass


class OpCode(Enum):
    Ping = 1
    CopyRequest = 2
    PasteRequest = 3
    ClipboardContents = 4
    EndOfClipboard = 5
    Ack = 6
    Nak = 7


class Message(object):
    header_fmt = '!3siBH'
    preamble = b'RCL'
    hmac_digest = 'sha256'

    def __init__(
        self,
        secret: bytes,
        sock: socket.socket,
        opcode: OpCode,
        data: bytearray=bytearray()
    ):
        self.secret = secret
        self.sock = sock
        self.opcode = opcode
        self.data = data

    def __repr__(self):
        return '<Message {} {}>'.format(self.opcode, len(self.data))

    def send(self):
        if len(self.data) > MAX_MSG_LEN:
            raise MessageTooLargeError

        _hmac = hmac.new(self.secret, digestmod=Message.hmac_digest)

        hdr_data = struct.pack(
            Message.header_fmt,
            Message.preamble,
            int(time.time()),
            self.opcode.value,
            len(self.data),
        )
        _hmac.update(hdr_data)
        self.sock.sendall(hdr_data)
        logging.debug('SENDHEDR %s %s', self.opcode, len(self.data))

        _hmac.update(self.data)
        self.sock.sendall(self.data)
        logging.debug('SENDDATA %s', self.data)

        dgst = _hmac.digest()
        self.sock.sendall(dgst)
        logging.debug('SENDHMAC %s', binascii.hexlify(dgst))

    @staticmethod
    def recv(secret: bytes, sock: socket.socket) -> 'Message':
        _hmac = hmac.new(secret, digestmod=Message.hmac_digest)

        buf = sock.recv(struct.calcsize(Message.header_fmt))
        if len(buf) < struct.calcsize(Message.header_fmt):
            raise RClipProtocolError

        _hmac.update(buf)
        preamble, timestamp, opcode, length = struct.unpack(
            Message.header_fmt, buf
        )
        if preamble != Message.preamble:
            raise RClipProtocolError
        if abs(time.time() - timestamp) > TIME_DRIFT_ALLOWANCE:
            raise AuthenticationError

        msg = Message(secret, sock, OpCode(opcode))
        logging.debug('RECVHEDR %s %s', OpCode(opcode), length)
        msg.data = bytearray()
        bcount = length
        while bcount > 0:
            buf = sock.recv(min(bcount, MAX_MSG_LEN))
            if len(buf) == 0:
                raise RClipProtocolError
            _hmac.update(buf)
            msg.data.extend(buf)
            bcount -= len(buf)
        logging.debug('RECVDATA %s', msg.data)

        msg_dgst = bytearray()
        bcount = 32
        while bcount > 0:
            buf = sock.recv(min(bcount, 32))
            if len(buf) == 0:
                raise RClipProtocolError
            msg_dgst.extend(buf)
            bcount -= len(buf)

        logging.debug('RECVHMAC %s', binascii.hexlify(msg_dgst))
        if not hmac.compare_digest(_hmac.digest(), msg_dgst):
            raise AuthenticationError

        return msg


def reusable_tcp_socket() -> socket.socket:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    try:
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_FASTOPEN, 1)
    except OSError:
        pass
    return sock


def format_addr(addr):
    return ':'.join(map(str, addr))


class RClipServer(object):
    def __init__(self, secret: bytes, host: str, port: int, singleton=False):
        if singleton:
            sock = reusable_tcp_socket()
            try:
                sock.connect((host, port))
                Message(secret, sock, OpCode.Ping).send()
                msg = Message.recv(secret, sock)
                if msg.opcode == OpCode.Ping:
                    raise ServerExistsError
            except ServerExistsError:
                raise ServerExistsError
            except:
                pass
            finally:
                sock.close()

        self.secret = secret
        self.sock = reusable_tcp_socket()
        self.sock.bind((host, port))
        self.sock.listen()

    def listen_loop(self):
        while True:
            try:
                sock, addr = self.sock.accept()
            except KeyboardInterrupt:
                # XXX: there has to be a better way
                break

            try:
                msg = Message.recv(self.secret, sock)

                if msg.opcode == OpCode.Ping:
                    Message(self.secret, sock, OpCode.Ping).send()
                elif msg.opcode == OpCode.CopyRequest:
                    logging.info('COPY from %s', format_addr(addr))
                    self.copy(sock)
                elif msg.opcode == OpCode.PasteRequest:
                    logging.info('PASTE to %s', format_addr(addr))
                    self.paste(sock)
            except AuthenticationError:
                logging.warning('AuthenticationError: %s', format_addr(addr))
                sock.close()
            except RClipProtocolError:
                sock.close()

    def copy(self, sock: socket.socket):
        pbcopy = subprocess.Popen(['pbcopy'], stdin=subprocess.PIPE)
        try:
            msg = Message.recv(self.secret, sock)
            while msg.opcode == OpCode.ClipboardContents:
                pbcopy.stdin.write(msg.data)
                msg = Message.recv(self.secret, sock)

            if msg.opcode != OpCode.EndOfClipboard:
                raise RClipProtocolError

        except RClipProtocolError:
            pbcopy.kill()
        pbcopy.communicate()
        rc = pbcopy.wait(timeout=5)
        if rc == 0:
            opcode = OpCode.Ack
        else:
            opcode = OpCode.Nak
        Message(self.secret, sock, opcode).send()

    def paste(self, sock: socket.socket):
        pbpaste = subprocess.Popen(['pbpaste'], stdout=subprocess.PIPE)
        buf = pbpaste.stdout.read(MAX_MSG_LEN)
        while len(buf) > 0:
            Message(self.secret, sock, OpCode.ClipboardContents, buf).send()
            buf = pbpaste.stdout.read(MAX_MSG_LEN)
        Message(self.secret, sock, OpCode.EndOfClipboard).send()
        msg = Message.recv(self.secret, sock)
        if msg.opcode == OpCode.Ack:
            pass
        elif msg.opcode == OpCode.Nak:
            pass
        else:
            raise RClipProtocolError


class RClipClient(object):
    def __init__(self, secret: bytes, host: str, port: int):
        self.secret = secret
        self.sock = reusable_tcp_socket()
        self.sock.connect((host, port))

    def paste(self):
        Message(self.secret, self.sock, OpCode.PasteRequest).send()
        msg = Message.recv(self.secret, self.sock)
        while msg.opcode == OpCode.ClipboardContents:
            sys.stdout.buffer.write(msg.data)
            msg = Message.recv(self.secret, self.sock)
        Message(self.secret, self.sock, OpCode.Ack).send()

    def copy(self):
        Message(self.secret, self.sock, OpCode.CopyRequest).send()
        buf = sys.stdin.buffer.read(MAX_MSG_LEN)
        while len(buf) > 0:
            Message(self.secret, self.sock, OpCode.ClipboardContents,
                    buf).send()
            buf = sys.stdin.buffer.read(MAX_MSG_LEN)
        Message(self.secret, self.sock, OpCode.EndOfClipboard).send()
        msg = Message.recv(self.secret, self.sock)
        if msg.opcode == OpCode.Ack:
            pass
        elif msg.opcode == OpCode.Nak:
            raise CopyFailedError
        else:
            raise RClipProtocolError


def main():
    called_as = sys.argv[0]

    try:
        mode = sys.argv[1]
    except IndexError:
        if called_as.endswith('copy'):
            mode = 'copy'
        elif called_as.endswith('paste'):
            mode = 'paste'
        else:
            mode = 'server'

    if mode.endswith('-secret'):
        if mode == 'generate-secret':
            secret = os.urandom(SECRET_SIZE)
        elif mode == 'set-secret':
            hexsecret = input('secret: ')
            if len(hexsecret) != SECRET_SIZE * 2:
                opoo('secret should be 32 bytes')
                sys.exit(1)
            try:
                secret = binascii.unhexlify(hexsecret)
            except binascii.Error:
                opoo(
                    'secret format error, expected 32 bytes in hexadecimal format'
                )
                sys.exit(1)

        CONFIG_DIR.mkdir(0o700, parents=True, exist_ok=True)
        with SECRET_FILE.open('wb') as sf:
            sf.write(binascii.hexlify(secret))
        opoo('secret written to', SECRET_FILE)

        sys.exit(0)

    try:
        port = int(sys.argv[2])
    except IndexError:
        port = DEFAULT_PORT

    if not SECRET_FILE.exists():
        opoo(
            'shared secret does not exist.'
            'run `rclip generate-secret` to generate or `rclip set-secret` to use an existing one'
        )
        sys.exit(1)

    secret = binascii.unhexlify(SECRET_FILE.read_text().strip())

    if mode == 'secret':
        print(binascii.hexlify(secret).decode('ascii'))
    elif mode.endswith('server'):
        singleton = False
        if mode == 'ensure-server':
            singleton = True
        try:
            server = RClipServer(secret, '127.0.0.1', port, singleton)
        except ServerExistsError:
            sys.exit(0)
        server.listen_loop()

    elif mode == 'copy':
        try:
            client = RClipClient(secret, '127.0.0.1', port)
        except socket.error:
            opoo('connection failed')
            sys.exit(1)
        try:
            client.copy()
        except CopyFailedError:
            opoo('server error occurred while copying')
            sys.exit(1)
        except RClipProtocolError:
            opoo('protocol error occurred while copying')
            sys.exit(1)
        except socket.error as e:
            opoo('error occurred while copying', e)
            sys.exit(1)

    elif mode == 'paste':
        try:
            client = RClipClient(secret, '127.0.0.1', port)
        except socket.error:
            opoo('connection failed')
            sys.exit(1)
        try:
            client.paste()
        except RClipProtocolError:
            opoo('protocol error occurred while pasting')
            sys.exit(1)
        except socket.error as e:
            opoo('error occurred while pasting', e)
            sys.exit(1)
    else:
        opoo('unknown mode', mode)


if __name__ == '__main__':
    main()
